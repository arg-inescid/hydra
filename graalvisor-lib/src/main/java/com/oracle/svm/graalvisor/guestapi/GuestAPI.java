package com.oracle.svm.graalvisor.guestapi;

import static com.oracle.svm.graalvisor.utils.JsonUtils.json;
import static com.oracle.svm.graalvisor.utils.StringUtils.retrieveString;
import static com.oracle.svm.graalvisor.utils.file.FileAccessModeUtils.getFileAccessMode;

import java.io.IOException;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;

import org.graalvm.nativeimage.ObjectHandle;
import org.graalvm.nativeimage.ObjectHandles;
import org.graalvm.nativeimage.PinnedObject;
import org.graalvm.nativeimage.RuntimeOptions;
import org.graalvm.nativeimage.c.function.CEntryPoint;
import org.graalvm.nativeimage.c.type.CCharPointer;
import org.graalvm.nativeimage.c.type.CTypeConversion;
import org.graalvm.word.WordFactory;

import com.oracle.svm.graalvisor.GraalVisor;
import com.oracle.svm.graalvisor.guestapi.file.FileAccessMode;
import com.oracle.svm.graalvisor.types.GraalVisorIsolateThread;
import com.oracle.svm.graalvisor.types.GuestIsolateThread;

/**
 * API used in guest application, note that the file manipulation apis only work in SVM
 */
@SuppressWarnings("unused")
public class GuestAPI {

    protected static Method method;
    private volatile static GraalVisor.GraalVisorStruct graalVisorStructHost;
    /*
     * In this example, we assume that there is fixed binding between host thread and guest isolate.
     * Only one thread would visit this guest.
     */
    private volatile static GraalVisorIsolateThread hostIsolateThread;
    private volatile static boolean functionRegistered = false;

    /**
     * Register the guest application class name in order to use reflection to invoke application
     * function. Each guest application should implement the function: {@code public static String
     * main(Map<String,Object> arguments)}
     *
     * @param applicationClassName fully-qualified class name of guest application
     * @throws ClassNotFoundException If this is happened on Substrate VM, check reflections
     *             configurations generated by tracing agent.
     * @throws NoSuchMethodException Make sure the class has the function implemented:
     *             {@code public static String
     *                                main(Map<String,Object> arguments)}
     */
    protected static void setApplicationClassName(String applicationClassName) throws ClassNotFoundException, NoSuchMethodException {
        Class<?> cls = Class.forName(applicationClassName);
        method = cls.getMethod("main", Map.class);
    }

    /**
     * Java entry point for graalvisor to call main function in guest application
     *
     * @param arguments arguments passed to the guest application main function
     * @return return String as invocation result
     * @throws InvocationTargetException indicates that there is exception happens inside *
     *             application function
     */
    protected static String invoke(String arguments) throws InvocationTargetException, IllegalAccessException {
        Map<String, Object> input = null;
        try {
            if (arguments != null && arguments.length() > 0) {
                input = json.mapFrom(arguments);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        if (input == null) {
            input = new HashMap<>();
        }
        try {
            if (method != null) {
                return json.asString(method.invoke(null, new Object[]{input}));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "Fail to convert invocation result to json.";
    }

    /**
     * C entrypoint function for installing GraalVisor into guest isolate
     *
     * @param guestThread target guest isolate thread
     * @param hostThread current
     * @param graalvisorStruct pointer to the GraalVisor host
     */
    @CEntryPoint(name = "guest_install_graalvisor", include = AsGraalVisorGuest.class)
    private static void guestInstallGraalvisor(@CEntryPoint.IsolateThreadContext GuestIsolateThread guestThread, GraalVisorIsolateThread hostThread, GraalVisor.GraalVisorStruct graalvisorStruct) {
        if (graalVisorStructHost.isNonNull()) {
            return;
        }
        hostIsolateThread = hostThread;
        graalVisorStructHost = graalvisorStruct;
    }

    /**
     * C entrypoint function for invoke guest application main function.
     *
     * @param guestThread guest isolate thread
     * @param classHandle handle for fully-qualified class name
     * @param argumentHandle handle for fully-qualified class name
     * @return handle for invocation result
     * @throws InvocationTargetException indicates that there is exception happens inside
     *             application function
     */
    @CEntryPoint(name = "invoke_main_function", include = AsGraalVisorGuest.class)
    private static ObjectHandle invoke(@CEntryPoint.IsolateThreadContext GuestIsolateThread guestThread, ObjectHandle classHandle, ObjectHandle argumentHandle)
                    throws InvocationTargetException, IllegalAccessException {
        String functionName = retrieveString(classHandle);
        String arguments = retrieveString(argumentHandle);
        if (!functionRegistered) {
            try {
                setApplicationClassName(functionName);
            } catch (ClassNotFoundException | NoSuchMethodException e) {
                e.printStackTrace();
                return copyStringToHost("Function not found!");
            }
            functionRegistered = true;
        }
        return copyStringToHost(invoke(arguments));
    }

    /**
     * C entry point to copy string into guest isolate heap space
     *
     * @param guestThread target guest isolate
     * @param cString CCharPointer to the beginning of the string
     * @return registered object handle for copied string, would is going to be used later for
     *         String retrieval.
     */
    @CEntryPoint(name = "guest_receive_string", include = AsGraalVisorGuest.class)
    private static ObjectHandle guestReceiveString(@CEntryPoint.IsolateThreadContext GuestIsolateThread guestThread, CCharPointer cString) {
        /* Convert the C string to the target Java string. */
        String targetString = CTypeConversion.toJavaString(cString);
        /* Encapsulate the target string in a handle that can be returned to the source isolate. */
        return ObjectHandles.getGlobal().create(targetString);
    }

    /**
     * Guest API: Call host isolate to receive the string
     *
     * @param resultString String that allocated in guest heap space and need to be copied to the
     *            host.
     * @return {@code ObjectHandle} that points to the copy in host heap space.
     */
    protected static ObjectHandle copyStringToHost(String resultString) {
        try (CTypeConversion.CCharPointerHolder cStringHolder = CTypeConversion.toCString(resultString)) {
            return graalVisorStructHost.getHostReceiveStringFunction().invoke(hostIsolateThread, cStringHolder.get());
        }
    }

    /**
     * Guest API: Delegate host to open a file for the guest.
     *
     * @param fileName file name going to be opened (created)
     * @param accessMode Different flags defined in {@link FileAccessMode} to open the file
     * @return file descriptor for the opened file
     */
    public static int openFile(String fileName, FileAccessMode accessMode) {
        try (CTypeConversion.CCharPointerHolder fileNameHolder = CTypeConversion.toCString(fileName)) {
            return graalVisorStructHost.getHostOpenFileFunction().invoke(hostIsolateThread, fileNameHolder.get(), getFileAccessMode(accessMode));
        }
    }

    /**
     * Guest API: Close the file using its file descriptor
     *
     * @param fd file descriptor of the opened file
     * @return returns zero on success. On error, -1 is returned, and errno is set to indicate the
     *         error.
     */
    public static int closeFile(int fd) {
        return graalVisorStructHost.getHostCloseFileFunction().invoke(hostIsolateThread, fd);
    }

    /**
     * Guest API: Write first {@param length} bytes in {@param buffer} to the file using its file
     * descriptor
     *
     * @param fd file descriptor of the output file
     * @param buffer bytes going to be written
     * @param length number of bytes going to be written
     */
    public static void writeBytes(int fd, byte[] buffer, int length) {
        try (PinnedObject buf = PinnedObject.create(buffer)) {
            graalVisorStructHost.getHostWriteBytesFunction().invoke(hostIsolateThread, fd, buf.addressOfArrayElement(0), WordFactory.unsigned(length));
        }
    }

    /**
     * Guest API: attempts to read up to count bytes from file descriptor fd into the buffer
     * starting at buf.
     *
     * @param fd file descriptor
     * @param buffer read buffer
     * @param bufferLen length of read buffer
     * @param readOffset offset for read buffer
     * @return number of bytes read
     */
    public static int readBytes(int fd, byte[] buffer, int bufferLen, int readOffset) {
        try (PinnedObject buf = PinnedObject.create(buffer)) {
            return graalVisorStructHost.getHostReadBytesFunction().invoke(hostIsolateThread, fd, buf.addressOfArrayElement(0), bufferLen, readOffset);
        }
    }

}
